# Predictive LL(1) Parser Implementation

This project implements a predictive LL(1) parser. It includes transforming a given grammar to an LL(1) form, computing the `FIRST()` and `FOLLOW()` sets, and constructing a table-driven predictive parser to determine if a given input string can be generated by the grammar.

## Table of Contents

- [Overview](#overview)
- [Project Structure](#project-structure)
- [System Requirements](#system-requirements)
- [How to Compile and Run](#how-to-compile-and-run)
- [Input Format](#input-format)

## Overview

This project consists of three main steps:

1. **Grammar Transformation**: The input grammar is transformed to an LL(1) grammar by eliminating left recursion and applying left factoring.
2. **Computation of FIRST() and FOLLOW() Sets**: The `FIRST()` and `FOLLOW()` sets for the LL(1) grammar are computed and stored.
3. **Table-Driven Predictive Parser**: A predictive parser is constructed using the `FIRST()` and `FOLLOW()` sets and the LL(1) grammar. The parser then checks if an input string is accepted by the grammar.

## Project Structure

- `Grammar.hpp` and `Grammar.cpp`: Define the grammar structure and provide methods for transformation and computation of `FIRST()` and `FOLLOW()` sets.
- `PredictiveParser.hpp` and `PredictiveParser.cpp`: Define and implement the predictive parser.
- `Makefile`: Automates the building process for the project.

## System Requirements

- **Compiler**: A C++20 compatible compiler (e.g., GCC, Clang).
- **Build Tool**: Make

## How to Compile and Run

### 1. Clone the Repository

Clone this repository to your local machine.

### 2. Compile the Project

Navigate to the project directory and compile the code using the provided `Makefile`:

```bash
make
```

### 3. Run the Program

After successfully compiling the project, you can run the program:

```bash
./main < input.txt
```
## Input Format

## Input Instructions

1. **Number of Terminals**: Enter the number of terminals.
2. **Number of Non-Terminals**: Enter the number of non-terminals.
3. **Terminal Symbols**: Enter the terminal symbols one by one.
4. **Non-Terminal Symbols**: Enter the non-terminal symbols one by one.
5. **Production Rules**: For each non-terminal, enter its production rules. Use the `!` symbol to indicate the end of the production rules for a non-terminal.
6. **Start Symbol**: Enter the start symbol for parsing (required when computing the `FOLLOW()` set).
7. **Input String**: Enter the input string to be parsed (for the predictive parser).

# Example Input
1
3
3
a b c
S A B
SbA
epsilon
!
Ac
a
!
bBc
epsilon
!
S
ababc

# Expected Output
Parse Table:
S[a]    =   S ---> SbA
S[b]    =   Error
S[c]    =   Error
S[$]    =   Error

A[a]    =   Error
A[b]    =   A ---> Ac
A[c]    =   Error
A[$]    =   A ---> epsilon
...

Input string is accepted by the grammar

